---
title: "基于 YubiKey 的冷钱包探索 3：使用 FIDO2 派生 KEK 加密私钥并管理以太坊地址"
date: 2025-10-20T00:00:00+08:00
author: "Lucas"
draft: false
tags: ["YubiKey","coldwallet","hardware wallet","FIDO2","Ethereum","security"]
keywords: ["YubiKey", "fido", "private", "冷钱包", "coldwallet"]
categories: 
  - "coldwallet"
  - "Ethereum"
description: "介绍如何用 YubiKey FIDO2 的 PRF 扩展派生密钥(KEK),用以 AES-GCM 加密本地私钥,并用一个轻量 keystore 管理以太坊地址.包含设计原理/安全性讨论与使用指南."
---

# 基于 YubiKey 的冷钱包探索 3：使用 FIDO2 派生 KEK 加密私钥并管理以太坊地址

本篇文章以实用与工程实现为主,介绍一个基于 YubiKey(FIDO2)PRF 扩展的本地冷钱包思路：  
使用 YubiKey 在用户触控与 PIN 验证后对**每条私钥**计算一次 PRF(salt),再用 HKDF-SHA256 将 PRF 输出扩展为对称密钥(KEK),以 AES-256-GCM 加密私钥并把最小必要的元数据(rp_id/credential_id/salt_prf/iv/ciphertext/address 等)写入本地 `privkey_keystore.json`.后续解密需要同一 YubiKey/同一 RP ID 与同一 credential_id,并在用户同意触控/输入 PIN 后复现 KEK 解密出私钥.

本文说明代码的设计逻辑/关键安全考量/使用方法与示例,并提供源码链接与可下载的示例 keystore 结构说明.

---

## 项目背景与目标

目标是实现一个**离线/本地**/私钥不可导出的冷钱包工作流,其中：

- 所有私钥以加密形式保存在本地(JSON keystore),当需要生成链上签名(或导出私钥)时,必须有 YubiKey 的物理接触与 PIN(如果启用).
- 使用 FIDO2 的 PRF(HMAC-like)扩展作为“不可提取”的硬件辅助秘密：设备内的凭证私钥与设备固件配合,基于提供的 salt 返回 32 字节 PRF 输出.该输出再经 HKDF-SHA256 得到 KEK,用于对称加密.
- 每个条目(entry)使用独立的随机 `salt_prf`,避免不同私钥间 KEK 重用;加密采用 AES-256-GCM,带 AAD(包含 rp_id)防止混淆上下文.

设计目标要点：

1. **最小化本地攻击面**：本地文件仅包含 ciphertext/iv/salt_prf/credential_id 与 rp_id.没有私钥明文,也不存储 KEK.
2. **物理控制**：解密需要 YubiKey 的存在/用户触控(或其他用户验证),并可能需要 PIN.
3. **可扩展**：一个 credential_id 可以保护多个私钥(每个私钥独立 salt);entry 格式简单,便于导入/导出/迁移.
4. **本地离线友好**：RP 校验在实现中采用宽松模式以便本地实验(`rp_id` 明确记录在 keystore 中),生产请使用真实域名并移除“宽松校验”.

---

## 核心设计与代码架构(高层)

项目主要模块/职责如下：

- `fido2_kek.py`(核心)：封装与 YubiKey 通信的逻辑,提供：
  - 注册发现性凭证(discoverable credential).
  - 调用 FIDO2 PRF 扩展计算 `PRF(salt)`.
  - 将 `PRF(salt)` 用 HKDF-SHA256 扩展为 KEK(长度可定制,默认 32 字节).
  - 提供高层 `get_kek(client, credential_id_hex, info, salt_prf)`：若 `salt_prf` 为 `None`,生成随机 salt 并返回 `(kek, salt_prf)`;若给定 salt,会复现同一 KEK.
- `privkey_keystore.json`(本地 keystore)：保存 `rp_id`/`kdf`/`kdfparams`/以及 `entries` 数组.每条 entry 包含 `id`/`address`/`salt_prf`/`crypto`(cipher/iv/ciphertext).
- `cli`(交互脚本)：用于生成私钥/调用 YubiKey 得到 KEK/AES-GCM 加密私钥并写入 keystore;以及读取 keystore/调用 YubiKey 得到 KEK 解密私钥.脚本提供三类操作：
  1. 生成并追加以太坊地址(自动生成 ECDSA/secp256k1 私钥并获得以太坊地址).
  2. 解密某条地址获得私钥(仅在用户触控并验证后).
  3. 创建新的 FIDO2 凭证并打印 `rp_id` / `credential_id`(便于备份与记录).

---

## 为什么这样设计(安全与实用性说明)

### 使用 YubiKey PRF 的动机

- YubiKey 上的 credential 私钥(用于公钥/签名)不可导出.PRF 扩展允许设备在不暴露私钥的情况下,计算基于设备私钥的 HMAC 型输出 `PRF(salt)`.利用该输出作为对称密钥的种子可以实现“硬件绑定的 KEK”.
- 相较于把设备上的签名私钥直接作为对称密钥(这通常不可行且语义不清),PRF 提供了一个标准化/可重复/可组合的方式来派生对称 KEK,并可以通过 `salt` 和 `info` 区分用途.

### 使用独立 `salt_prf` 的原因

- 若直接对所有私钥使用相同 PRF 输入,得到的 KEK 相同,则一个被解密的私钥即泄露保护其他所有私钥的能力(即**同钥多条**问题).通过对每条私钥使用独立随机 `salt_prf`,即便使用同一 credential_id,攻击者要解密任意一条,仍需在设备上触控并提供 PIN.

### 为什么依旧用 HKDF-SHA256

- PRF 输出是 32 字节“原始”结果,将其直接作为 KEK 是可行的,但使用 HKDF 带来的好处：
  - 明确区分用途：`info` 字段能够在同一 credential 上派生出不同用途的 KEK(例如 `privkey-v1`/`evm-priv-v1`),防止不同用途的密钥互相替代或滥用.
  - HKDF 提供额外的抗碰撞/拉开用途域(domain separation),是工程实践中的良好做法.
- 因此流程为：`PRF(salt)` → HKDF(info) → KEK → AES-256-GCM(IV, AAD)→ ciphertext.

### AES-GCM 的 AAD(认证附加数据)

- 我们把 `AAD = b"type=privkey|v=1|rp=<rp_id>"` 包含到加密中,这样在解密时会验证 AAD 是否一致,避免将同一 ciphertext 用在不同 RP 或不同用途场景下导致误解密或误用.

### 本地文件最小化存储

- `privkey_keystore.json` 只保存：
  - `rp_id` 与 `credential_id`(标识哪把 YubiKey /凭证可解密)
  - 对每条私钥：`salt_prf`(用于在设备上复现 PRF)/`iv`/`ciphertext`/已派生的 `address` 以及一个 UUID `id`
- 不保存 KEK/明文私钥或任何能直接伪造 PRF 的秘密.

---

## 使用说明(快速示例)

> 假设已安装 Python 依赖并将 YubiKey 插入,且你的 `fido2_kek.py` 与 CLI 脚本在同一目录.

1. 创建新的凭证并打印(可选)：
```
python3 cli.py
# 选择：3) create new fido2 credential and print rp_id / credential_id
# 记录 rp_id 与 credential_id 以便备份
```

2. 生成并追加新的以太坊地址(会在本地生成私钥/加密并写入 keystore)：
```
# 选择：1) generate and append new ethereum address
# 输入 keystore 路径(默认 privkey_keystore.json)
# 若文件不存在,会提示输入 rp_id 并在 YubiKey 上创建一个 discoverable credential(需要 PIN/触控)
# 若文件存在,会读取文件中的 rp_id 与 credential_id 并复用(无需新建凭证)
# 脚本会在设备上提示输入 PIN 与触控以派生 KEK(并生成 salt_prf)
```

3. 解密某个地址的私钥：
```
# 选择：2) decrypt one address
# 选择要解密的地址序号
# 脚本会向 YubiKey 请求 PRF(salt_prf)(需要 PIN/触控),并在本地用 AES-GCM 解密出私钥
```

注意：若键盘或终端提示“Please enter your YubiKey FIDO2 PIN”,请输入 YubiKey 的 FIDO2 PIN(默认可能为空但取决于你的配置).

---

## Keystore 格式说明(示例)

最小 keystore JSON(`privkey_keystore.json`)示例：
```json
{
  "rp_id": "wallet.local",
  "kdf": "fido2-prf+hkdf-sha256",
  "kdfparams": {
    "rp_id": "wallet.local",
    "credential_id": "52f92533242c...",
    "info": "privkey-v1"
  },
  "entries": [
    {
      "id": "5983c3f2-1a2b-4d4f-9a8d-5b6c7d8e9f00",
      "address": "0x8784c4c3e34168Ab3E49dEb74937Cf8F3847dA2d",
      "salt_prf": "b3f1a2... (64 hex chars)",
      "crypto": {
        "cipher": "aes-256-gcm",
        "iv": "<24 hex chars>",
        "ciphertext": "<ciphertext hex>"
      }
    }
  ]
}
```

关键点：

- `credential_id`：discoverable credential 的 ID(hex),用于在 YubiKey 上索引对应凭证进行 PRF.
- `salt_prf`：每条 entry 的随机 32 字节(以 hex 存储),在解密时需要把它传给设备以复现 PRF 输出.
- `iv` / `ciphertext`：AES-GCM 的 IV 与密文.
- `address`：明文保存以便快速展示,避免每次需要解密查看地址.

---

## 安全性讨论(威胁模型与防护)

### 假设的威胁模型

- 攻击者可能获得你的硬盘快照或备份(含 `privkey_keystore.json`).
- 攻击者可能短暂接触到你的机器,但**无法**控制或读取 YubiKey(物理隔离).
- 攻击者**可能**获得 YubiKey(这意味着严重风险,取决于是否知道 PIN).

### 风险与减缓措施

1. **本地文件被泄露**：文件本身仅包含 ciphertext 与 salt,无法在没有 YubiKey 的情况下解密.攻击者需要同时获得你的 YubiKey 并通过 PIN/触控才能复现 KEK.
2. **YubiKey 被盗**：若攻击者获得了 YubiKey **且**知道/绕过了 PIN,则可解密所有条目(同一 credential 的所有条目仍需要 salt,但 salt 存储于文件;因此窃取 YubiKey + 凭证 ID + PIN 就能解密).减缓：为 YubiKey 设置 PIN,并考虑用多因素或将凭证分布到多把 YubiKey.
3. **Side-channel / Host compromise**：若主机被完全控制(恶意驱动或内核级监控),则攻击者能在用户解密时即时拷贝明文私钥或劫持签名流程.减缓：尽量在离线/受信环境中进行敏感操作;使用离线签名策略(在隔离主机或受限环境签名).
4. **PRF / HKDF 安全**：PRF 由设备实现,理论上等价于 HMAC(K_cred, salt).HKDF 是公认的安全扩展.使用 info 作为用途分离是良好实践.

---

## 代码关键点(实现注意事项)

- 对于 `Fido2PRFClient`：
  - 在本地实验中使用了宽松的 CDC(Client Data Collector)以避免 origin/rp 限制;**生产必须删除该宽松策略** 并使用真实 `rp_id` 与 `origin`.
  - 操作需要用户 PIN(若启用)与触控(用户验证).
  - 处理 PIN 相关的错误与锁定(PIN_AUTH_BLOCKED/PIN_BLOCKED)并友好提示.

- `get_kek(...)`：
  - 若 `salt_prf` 为 `None`,函数会随机生成一个 32 字节 salt,调用 PRF 并返回 `(kek, salt_prf)`.
  - 若 `salt_prf` 已给定,函数只做 PRF 调用以复现之前的 KEK.

- AES-GCM：
  - IV 使用 12 字节随机值.
  - AAD 必须在加密与解密时一致(包含 `rp_id` 有助于防止跨 RP 混用).

- 错误处理：
  - 对文件结构/字段类型做轻量校验;解密失败会输出友好错误.
  - 对 YubiKey/CTAP 错误需明确区分 PIN 错误与其他错误并给出提示信息.

---

## 相关源码

- `fido2_kek.py`(派生 KEK / 与 YubiKey 交互):  
  https://github.com/lucas556/yubikey-wallet/blob/main/fido2_kek.py

- `seed_keystore.py`(早期的 seed keystore 实现,供对比):  
  https://github.com/lucas556/yubikey-wallet/blob/main/seed_keystore.py

建议查看上面两个文件以理解完整细节与历史演进.

---

## 常见问题

**Q: 为什么不直接把设备上的签名私钥用于链上签名？**  
A: 有些 YubiKey 应用(OpenPGP/PIV)支持 secp256k1,因此可以在设备上直接签名链上交易(例如导出公钥用于地址),但在很多平台上 FIDO2/CTAP 的签名语义与区块链签名语义不完全一致;PRF 提供的是对称密钥派生能力,适合把 YubiKey 作为“不可导出密钥”的种子,从而保护本地私钥的加密与解密流程.

**Q: PRF 输出是否可直接作为 AES 的密钥？**  
A: 技术上直接使用 PRF(salt) 的 32 字节作为 AES-256 密钥是可行的,但通过 HKDF 能够添加 `info` 做用途分离并具备更明确的密钥衍生语义,因此更推荐使用 HKDF.

---

## 总结

本文给出了一种利用 YubiKey FIDO2 PRF 扩展为本地私钥加密提供硬件绑定 KEK 的方法,权衡了工程实现与安全性.关键思想是**将不可导出的设备秘钥能力(PRF)作为派生对称密钥的根源**,再结合每条私钥独立 salt/HKDF 用途分离与 AES-GCM 加密,达到“本地存储而不可无凭证解密”的目标.

本文配套的示例代码实现了 CLI 工具,支持生成凭证/添加以太坊地址并加密私钥/以及在需要时用 YubiKey 解密私钥.若计划用于生产或大规模使用,请务必审计 YubiKey 配置(是否启用 PIN/是否使用真实 rp_id/origin)/审查主机安全与签名流程,并考虑更严格的硬件密钥管理策略(如多重备份/设备轮换等).

--- 

